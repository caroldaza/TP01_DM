---
title: "R Notebook"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---

```{r}
setwd('~/Documentos/DataMining/dm-uba.github.io-master/2021/tps_entregables/TP012021/')
```
```{r include = FALSE}
knitr::opts_chunk$set(echo=FALSE)
```

*Imports*

```{r}
library(mongolite)
library(modeest)
library(ggplot2)
library(jsonlite)
library(dplyr)
library(easyGgplot2)
library(tidyr)
library(ggpubr)
theme_set(theme_pubclean())
```

*Carga datasets*

```{r results="hide"}
#artistas = mongo(db = "DMUBA_SPOTIFY", collection = 'artist')
#artist <- artistas$find('{}')

#chart = mongo(db = "DMUBA_SPOTIFY", collection = 'charts')
#charts <- chart$find('{}')

#artista_audio_features = mongo(db = "DMUBA_SPOTIFY", collection ='artist_audio_features_solo')
#artist_audio_features <- artista_audio_features$find('{}')

artist = stream_in(file("~/Documentos/DataMining/dm-uba.github.io-master/2021/tps_entregables/TP012021/datasets/artist-dm.json",open="r"))
charts= stream_in(file("~/Documentos/DataMining/dm-uba.github.io-master/2021/tps_entregables/TP012021/datasets/charts-dm.json",open="r"))
artist_audio_features = stream_in(file("~/Documentos/DataMining/dm-uba.github.io-master/2021/tps_entregables/TP012021/datasets/artist_audio_features_solo_art-dm.json",open="r"))

```

*Atributos*

-Artista:

```{r}
# Nombres columnas
names(artist)
# Tamaño dataframe
dim(artist)
```

```{r}
aux <- unique(artist)
head(aux,5)
```

No hay artistas repetidos en Artist:

```{r}
dim(aux)
```

No hay missings en Artist:

```{r}
colSums(is.na(artist))  
```

-Charts

```{r}
# Nombres columnas
names(charts)
# Tamaño dataframe
dim(charts)
```

No hay missings en charts:

```{r}
colSums(is.na(charts))  
```

Cantidad de datos por año en charts:

```{r}
date <- format(as.Date(charts$week_start, format="%Y-%m-%d"),"%Y")
table(date)
```

Hacemos unique de charts para ver si hay repetidos:

```{r}
dim(charts)
dim(unique(charts))
```

Hay filas que son la misma pero tienen distinto identificador.
Ahora en cada subconjunto vemos si hay repetidos sacando la columna del identificador:

```{r}
subconjunto_charts0 <- charts[,c(2:8)]
# creo columna adicional que extrae el ago
subconjunto_charts0$agno <- format(as.Date(charts$week_start, format="%Y-%m-%d"),"%Y")
```

agno 2018:

```{r}
subconjunto_charts_2018 <- subconjunto_charts0[subconjunto_charts0$agno=='2018',]
aux1<-unique(subconjunto_charts_2018)
aux1<-aux1[order(aux1$Artist),]
```

```{r}
dim(aux1)
dim(unique(aux1))
```

agno 2019:

```{r}
subconjunto_charts_2019 <- subconjunto_charts0[subconjunto_charts0$agno=='2019',]
aux2<-unique(subconjunto_charts_2019)
aux2<-aux2[order(aux2$Artist),]
```

```{r}
dim(aux2)
dim(unique(aux2))
```

agno 2020:

```{r}
subconjunto_charts_2020 <- subconjunto_charts0[subconjunto_charts0$agno=='2020',]
aux3<-unique(subconjunto_charts_2020)
aux3<-aux3[order(aux3$Artist),]
```

```{r}
dim(aux3)
dim(unique(aux3))
```

agno 2021:

```{r}
subconjunto_charts_2021 <- subconjunto_charts0[subconjunto_charts0$agno=='2021',]
aux4<-unique(subconjunto_charts_2021)
aux4<-aux4[order(aux4$Artist),]
```

```{r}
dim(aux4)
dim(unique(aux4))
```

Confirmamos que ya no hay repetidos si hacemos unique de charts sin identificador.

```{r}
sub_charts <-unique(subconjunto_charts0)
```


- *Tracks*

Cantidad de tracks por artista ordenados de mas tracks a menos (se puede hacer por agno tambien con los subconjuntos de mas arriba):

```{r}
trackxartist <- aggregate(Track_Name ~Artist, data=sub_charts, FUN=length)
colnames(trackxartist) <- c("Artist","Cantidad_tracks")
trackxartist<-trackxartist[order(-trackxartist$Cantidad_tracks),]
head(trackxartist,5)
```
Post Malone y Billie Eilish tienen mas tracks en los listados en total.

```{r}
summary(trackxartist)
```
Del histograma podemos ver que las medidas de tendencia central no son representativas:

```{r fig.height=3, fig.width=4}
hist(log(trackxartist$Cantidad_tracks), xlab = "Log(Tracks)", ylab = "Freq", 
        main="Cantidad de tracks por artista",breaks=100) 
```

Muchos artistas tienen pocos tracks. Parecce una distro multimodal. 

La dimension de tracks por artista debe ser la cantidad de artistas:

```{r}
dim(trackxartist)
```

Discriminando por agno:

-2018
```{r}
trackxartist_2018 <- aggregate(Track_Name ~Artist, data=aux1, FUN=length)
colnames(trackxartist_2018) <- c("Artist","Cantidad_tracks")
trackxartist_2018<-trackxartist_2018[order(-trackxartist_2018$Cantidad_tracks),]
head(trackxartist_2018,10)
```

-2019

```{r}
trackxartist_2019 <- aggregate(Track_Name ~Artist, data=aux2, FUN=length)
colnames(trackxartist_2019) <- c("Artist","Cantidad_tracks")
trackxartist_2019<-trackxartist_2019[order(-trackxartist_2019$Cantidad_tracks),]
head(trackxartist_2019,10)
```

-2020

```{r}
trackxartist_2020 <- aggregate(Track_Name ~Artist, data=aux3, FUN=length)
colnames(trackxartist_2020) <- c("Artist","Cantidad_tracks")
trackxartist_2020 <- trackxartist_2020[order(-trackxartist_2020$Cantidad_tracks),]
head(trackxartist_2020,10)
```

-2021

```{r}
trackxartist_2021 <- aggregate(Track_Name ~Artist, data=aux4, FUN=length)
colnames(trackxartist_2021) <- c("Artist","Cantidad_tracks")
trackxartist_2021 <- trackxartist_2021[order(-trackxartist_2021$Cantidad_tracks),]
head(trackxartist_2021,10)
```

Si tenemos en cuenta los 5 primeros lugares, Post Malone tuvo mas tracks en la lista por tres agnos seguidos, asi como Ed Sheeran. Billie Eilish va por ese camino. XXXTentation, Juice y Bad Bunny siguen con dos agnos seguidos de tener mas tracks en las listas. XXXTentation fue popular en cuanto a numero de tracks durante 2018 y 2019 pero despues ya no estuvo entre los primeros 5.

- *Streams*

```{r}
summary(sub_charts$Streams)
```

El 50% de las reproducciones estan por debajo del orden de las ~6,53 millones de reproducciones y el maximo de reproducciones es del orden de ~71,47 millones de reproducciones. Del histograma podemos ver que las medidas de tendencia central no son representativas, parece ser una distribucion bimodal (?):

```{r fig.height=3, fig.width=3}
hist(log(sub_charts$Streams), xlab = "Log(streams)", ylab = "Freq", 
        main="Cantidad total de reproducciones",breaks=50) 
```
```{r fig.height=3, fig.width=4}
boxplot(sub_charts$Streams,ylab = "Valores", xlab = "Streams",main="Reproducciones de tracks")
```
Las medidas centrales no son representativas, en el boxplot se visualizan muchos outliers.

Por agno:

```{r fig.height=3, fig.width=4}
data <- sub_charts[c(4,8)]
mutate(data,agno=as.numeric(data$agno)) -> data
boxplot(data$Streams ~data$agno, ylab = "Streams", xlab = "Año",main="Reproducciones de tracks")
```
Las distribuciones discriminadas por agno tambien son muy asimetricas y con muchos outliers.

Cantidad media de streams por artista (totales, se podria hacer por año con los subconjuntos hechos mas arriba):

```{r}
streamsxartist <- aggregate(Streams ~Artist, data=sub_charts, FUN=mean)
streamsxartist<-streamsxartist[order(-streamsxartist$Streams),]
head(streamsxartist,10)
```

Se meten artistas antiguos en el ranking de popularidad por reproducciones.

```{r}
summary(streamsxartist)
```

El 50% de los artistas tienen en promedio por debajo de ~6,16 millones de reproducciones.

```{r fig.height=3, fig.width=4}
hist(log(streamsxartist$Streams), xlab = "Log(streams)", ylab = "Freq", 
        main="Cantidad media de reproducciones", breaks=50) 
```

Del histograma podemos ver que las medidas de tendencia central tampoco son representativas pero la distribucion es un poco mas simetrica.

```{r fig.height=3, fig.width=4}
boxplot(streamsxartist$Streams, ylab = "Valores", xlab = "Streams",main="Reproducciones Medias de tracks")
```

Si consideramos el maximo de reproducciones para cada artista:

```{r}
streamsxartist_max <- aggregate(Streams ~Artist, data=sub_charts, FUN=max)
streamsxartist_max <-streamsxartist_max[order(-streamsxartist_max$Streams),]
streamsxartist_max
```

Al cambiar a maximo de reproducciones se meten mas artistas nuevos. Varios tambien tienen muchos tracks en las listas, otros se ve que son populares por una cancion (o algunas pocas) que pegaron.

```{r}
summary(streamsxartist_max)
```

Para el 50% de artistas su cancion mas escuchada tiene por debajo de ~8,34 millones de reproducciones. El maximo es de ~71,47 millones.

Del histograma podemos ver que las medidas de tendencia central no son representativas, la ditribucion parece ser multimodal y es mas asimetrica que si consideramos las medias:

```{r fig.height=3, fig.width=4}
hist(log(streamsxartist_max$Streams), xlab = "Log(streams)", ylab = "Freq", 
        main="Cantidad maxima de reproducciones", breaks=50) 
```

```{r fig.height=3, fig.width=4}
boxplot(streamsxartist_max$Streams, ylab = "Valores", xlab = "Streams",main="Reproducciones Maximas de tracks")
```

- *Canciones top*

Hay 39 canciones que han ocupado el primer lugar (total, tambien se puede discriminar por año):

```{r}
sub_charts2 <- sub_charts[c(1,2,3,8)]
tabla_top <- sub_charts2[sub_charts2$Position == 1,] 
top_tracks <- unique(tabla_top)
head(top_tracks,5)

```
por agno:

-2018

```{r}
sub_charts2 <- sub_charts[c(1,2,3,8)]
tabla_top_2018 <- sub_charts2[sub_charts2$Position == 1 & sub_charts2$agno==2018,] 
top_tracks_2018 <- unique(tabla_top_2018)
head(top_tracks_2018,10)
```

-2019

```{r}
sub_charts2 <- sub_charts[c(1,2,3,8)]
tabla_top_2019 <- sub_charts2[sub_charts2$Position == 1 & sub_charts2$agno==2019,] 
top_tracks_2019 <- unique(tabla_top_2019)
head(top_tracks_2019,10)

```

-2020

```{r}
sub_charts2 <- sub_charts[c(1,2,3,8)]
tabla_top_2020 <- sub_charts2[sub_charts2$Position == 1 & sub_charts2$agno==2020,] 
top_tracks_2020 <- unique(tabla_top_2020)
head(top_tracks_2020,10)

```

-2021

```{r}
sub_charts2 <- sub_charts[c(1,2,3,8)]
tabla_top_2021 <- sub_charts2[sub_charts2$Position == 1 & sub_charts2$agno==2021,] 
top_tracks_2021 <- unique(tabla_top_2021)
head(top_tracks_2021,10)

```

Se observa que las canciones top cambian a cada agno. Se podria discriminar tambien por temporada.

-*Artistas*

Artistas con mas canciones en el primer lugar:

```{r}
NumberOnexartist <- aggregate(Track_Name ~ Artist , tabla_top, function(x) length(unique(x)))
colnames(NumberOnexartist) <- c("Artist","Canciones_Top")
NumberOnexartist <-NumberOnexartist[order(-NumberOnexartist$Canciones_Top),]
head(NumberOnexartist,5)
```

De nuevo repiten varios de los artistas que tienen mas canciones en las listas y con mas reproducciones, pero las canciones que son top para cada artista son unas pocas.


Se puede discriminar tambien por agno:

-2018
```{r}
NumberOnexartist_2018 <- aggregate(Track_Name ~ Artist , tabla_top_2018, function(x) length(unique(x)))
colnames(NumberOnexartist_2018) <- c("Artist","Canciones_Top")
NumberOnexartist_2018 <-NumberOnexartist_2018[order(-NumberOnexartist_2018$Canciones_Top),]
head(NumberOnexartist_2018,5)
```

-2019
```{r}
NumberOnexartist_2019 <- aggregate(Track_Name ~ Artist , tabla_top_2019, function(x) length(unique(x)))
colnames(NumberOnexartist_2019) <- c("Artist","Canciones_Top")
NumberOnexartist_2019 <-NumberOnexartist_2019[order(-NumberOnexartist_2019$Canciones_Top),]
head(NumberOnexartist_2019,5)
```

-2020
```{r}
NumberOnexartist_2020 <- aggregate(Track_Name ~ Artist , tabla_top_2020, function(x) length(unique(x)))
colnames(NumberOnexartist_2020) <- c("Artist","Canciones_Top")
NumberOnexartist_2020 <-NumberOnexartist_2020[order(-NumberOnexartist_2020$Canciones_Top),]
head(NumberOnexartist_2020,5)
```
-2020
```{r}
NumberOnexartist_2021 <- aggregate(Track_Name ~ Artist , tabla_top_2021, function(x) length(unique(x)))
colnames(NumberOnexartist_2021) <- c("Artist","Canciones_Top")
NumberOnexartist_2021 <-NumberOnexartist_2021[order(-NumberOnexartist_2021$Canciones_Top),]
head(NumberOnexartist_2021,5)
```

Durante la cuatentena se volvio mas dificil pegar hits?

-*Features*

```{r}
# Nombres columnas
names(artist_audio_features)
# Tamaño dataframe
dim(artist_audio_features)
```
Hay missings:

```{r}
colSums(is.na(artist_audio_features))  
```
Son album_release_year y track_preview_ulr. Podemos no considerar esos atributos.


```{r}
sub_audio_features <- unique(artist_audio_features)
dim(sub_audio_features)
```
Hay filas 25428 repetidas. Uso sub_audio_features que las unifica.

Teniendo la informacion de cuales artistas son los mas populares por numero de tracks en los listados y por tracks numero uno, podemos reducir nuestro analisis de features que hacen que una cancion o artista sea top a estas canciones y artistas.

Antes hay que cruzar la lista de artistas con los del archivo de audio features para que solo esten artistas del archivo de artistas.

Cambiamos el nombre de la columna artist_name en sub_audio_features para poder hacer un join:

```{r}
 names(sub_audio_features)[names(sub_audio_features)=="artist_name"] <- "Artist" 
```

Hacemos un semi-join para que solo queden las columnas de sub_audio_features que estan en charts:

```{r}
audio_features_clean <- semi_join(sub_audio_features, sub_charts , by = "Artist")
```

Con audio_features_clean y con sub_charts podemos hacer el analisis de los outliers y las correlaciones.

-*Distribuciones*

Histogramas de las variables audio features:

```{r}
data_features <- audio_features_clean[c(2,15,17,18,21,26,27,30,31,32,40)]
names(data_features)
```

```{r }
# Histograma Urban MPI
plot1 <- ggplot2.histogram(data_features[,1], title = "Histograma Acousticness", 
     xtitle = "acousticness", ytitle = "Frecuencia", backgroundColor="white", color="black", fill='#FFAAD4')
# Histograma Rural MPI
plot2 <- ggplot2.histogram(data_features[,2], main = "Histograma danceability", 
     xtitle = "danceability", ytitle = "Frecuencia", backgroundColor="white", color="black", fill='#FFAAD4')
# Histograma National MPI
plot3 <- ggplot2.histogram(data_features[,3], main = "Histograma duration_ms", 
     xtitle = "duration(ms)", ytitle = "Frecuencia", backgroundColor="white", color="black", fill='#FFAAD4')
# Histograma Regional MPI
plot4 <-ggplot2.histogram(data_features[,4], main = "Histograma energy", 
     xtitle = "energy", ytitle = "Frecuencia", backgroundColor="white", color="black", fill='#FFAAD4')
#
plot5 <-ggplot2.histogram(data_features[,5], main = "Histograma instrumentalness", 
     xtitle = "instrumentalness", ytitle = "Frecuencia", backgroundColor="white", color="black", fill='#FFAAD4')
#
plot6 <-ggplot2.histogram(data_features[,6], main = "Histograma liveness", 
     xtitle = "liveness", ytitle = "Frecuencia", backgroundColor="white", color="black", fill='#FFAAD4')
#
plot7 <-ggplot2.histogram(data_features[,7], main = "Histograma loudness", 
     xtitle = "loudness", ytitle = "Frecuencia", backgroundColor="white", color="black", fill='#FFAAD4')
#
plot8 <-ggplot2.histogram(data_features[,8], main = "Histograma speechiness", 
     xtitle = "speechiness", ytitle = "Frecuencia", backgroundColor="white", color="black", fill='#FFAAD4')
#
plot9 <-ggplot2.histogram(data_features[,9], main = "Histograma tempo", 
     xtitle = "tempo", ytitle = "Frecuencia", backgroundColor="white", color="black", fill='#FFAAD4')
#
plot10 <-ggplot2.histogram(data_features[,10], main = "Histograma time_signature", 
     xtitle = "time_signature", ytitle = "Frecuencia", backgroundColor="white", color="black", fill='#FFAAD4')
#
plot11 <-ggplot2.histogram(data_features[,11], main = "Histograma valence", 
     xtitle = "valence", ytitle = "Frecuencia", backgroundColor="white", color="black", fill='#FFAAD4')

ggplot2.multiplot(plot1,plot2,plot3,plot4,plot5,plot6,plot7,plot8,plot9,plot10,plot11, cols=3)
```

De la variable time_signature se puede deducir directamente que la gran mayoria de las canciones en los listados estan compuestas en compases simples 4 tiempos. Para las demas analizamos los boxplots y z_scores.

-*Boxplots*

Normalizo los atributos para observar los boxplot al tiempo:

```{r}
data_features_max<-apply(abs(data_features),2,max)
data_features_n <- mapply(`/`, data_features, data_features_max)
```

```{r}
box_data <- data_features_n[,c(1:9,11)]
boxplot(box_data,main="Boxplots audio features normalizadas",las=2)
```
Este metodo no seria el adecuado para detectar outliers en la mayoria de los audio features, probablemente solo para acousticness y valence. En tal caso podriamos decir que estas dos variables no poseen outliers notables, pero las vamos a analizar por otros metodos.

-*Z-score*

Analizamos con z-score las distribuciones mas simetricas, que vendrian siendo tempo y valence.

Sacando time signature:

```{r}
data_features <- audio_features_clean[c(2,15,17,18,21,26,27,30,31,40)]
names(data_features)
```

```{r}
data_tempo_valence <- data_features[c(9,10)]
means <- apply(data_tempo_valence, 2, mean, na.rm=TRUE)
desvs <- apply(data_tempo_valence, 2, sd, na.rm = TRUE)
# tuve que escribirlo explicitamente porque no encontre como escribir elementwise en R
z_score <- matrix(0, ncol =length(data_tempo_valence) , nrow = nrow(data_tempo_valence)) 
z_score[,1] <- (data_tempo_valence[,1]-means[1])/desvs[1]
z_score[,2] <- (data_tempo_valence[,2]-means[2])/desvs[2]

```

Los outliers superiores:

```{r}
threshold = 3.5

# Los zscores
var <- z_score[,1]
L <- var[var>threshold]
umb_sup_z <- list(L)

var <- z_score[,2]
L_new = list(var[var>threshold])
umb_sup_z <- c(umb_sup_z,L_new)
  
# los oultiers
var <- z_score[,1]
var2 <- data_features[,9]
L2 <- var2[var>threshold]
outl_sup_z <- list(L2)

var <- z_score[,2]
var2 <- data_features[,10]
L2_new = list(var2[var>threshold])
outl_sup_z <- c(outl_sup_z,L2_new)

```

Etiqueto los outliers superiores:

```{r}
data_tempo_valence <- mutate(data_tempo_valence,out_tempo=if_else(data_tempo_valence$tempo %in% outl_sup_z[[1]],1,0))
data_tempo_valence <- mutate(data_tempo_valence,out_valence=if_else(data_tempo_valence$valence %in% outl_sup_z[[2]],1,0))
```

Los outliers inferiores:

```{r}
threshold = -3.5

# Los zscores
var <- z_score[,1]
L <- var[var<threshold]
umb_inf_z <- list(L)

var <- z_score[,2]
L_new = list(var[var<threshold])
umb_inf_z <- c(umb_inf_z,L_new)
  
# los oultiers
var <- z_score[,1]
var2 <- data_features[,9]
L2 <- var2[var<threshold]
outl_inf_z <- list(L2)

var <- z_score[,2]
var2 <- data_features[,10]
L2_new = list(var2[var<threshold])
outl_inf_z <- c(outl_inf_z,L2_new)

```

Etiqueto los outliers inferiores:

```{r}
data_tempo_valence <- mutate(data_tempo_valence,out_tempo_in=if_else(data_tempo_valence$tempo %in% outl_inf_z[[1]],1,0))
data_tempo_valence <- mutate(data_tempo_valence,out_valence_in=if_else(data_tempo_valence$valence %in% outl_inf_z[[2]],1,0))
```

```{r}
#data<- data_tempo_valence %>%
#  pivot_longer(cols = c("tempo","valence"), names_to = "Var", values_to = "Val")

#ggplot(data, aes(x = Var, y = Val, fill=out_tempo)) +
#      geom_boxplot()
```

Aqui se puede observar los outliers calculados con este metodo en color azul:

```{r fig.width=4, fig.height=4 }
puntos1 <- outl_sup_z[[1]]
puntos2 <- outl_inf_z[[1]]

boxplot(data_tempo_valence$tempo,main="Boxplot tempo")
stripchart(puntos1, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'blue')
stripchart(puntos2, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'blue')
```
Para valence no encuentra outliers. Los datos que tienen tempo 0 es porque seguramente los llenaron con ceros por no tener datos.

-*Z-score modificado*

Para las otras variables de audio features:

```{r}
names(data_features)
```

```{r}
medians <- apply(data_features[,1:8], 2, median, na.rm=T)
MAD <- apply(data_features[,1:8], 2, mad, na.rm = T)
# tuve que escribirlo explicitamente porque no encontre como escribir elementwise en R
z_score_mod <- matrix(0, ncol = length(data_features[,1:8]) , nrow = nrow(data_features[,1:8])) 
z_score_mod[,1] <- 0.6745*(data_features[,1]-medians[1])/MAD[1]
z_score_mod[,2] <- 0.6745*(data_features[,2]-medians[2])/MAD[2]
z_score_mod[,3] <- 0.6745*(data_features[,3]-medians[3])/MAD[3]
z_score_mod[,4] <- 0.6745*(data_features[,4]-medians[4])/MAD[4]
z_score_mod[,5] <- 0.6745*(data_features[,5]-medians[5])/MAD[5]
z_score_mod[,6] <- 0.6745*(data_features[,6]-medians[6])/MAD[6]
z_score_mod[,7] <- 0.6745*(data_features[,7]-medians[7])/MAD[7]
z_score_mod[,8] <- 0.6745*(data_features[,8]-medians[8])/MAD[8]

#z_score_mod <- 0.6745*(data_features-medians)/MAD
```

Definiendo un umbral de 3,5 veces la mediana, calculamos los outliers superiores:

```{r}
threshold = 3.5
var <- z_score_mod[,1]
L <- var[var>threshold]
umbrales_sup <- list(L)

for (i in c(2:8)){
  var <- z_score_mod[,i]
  L_new = list(var[var>threshold])
  umbrales_sup <- c(umbrales_sup,L_new)
}
var <- z_score_mod[,1]
var2 <- data_features[,1]
L2 <- var2[var>threshold]
outliers_sup <- list(L2)

for (i in c(2:8)){
  var <- z_score_mod[,i]
  var2 <- data_features[,i]
  L2_new = list(var2[var>threshold])
  outliers_sup <- c(outliers_sup,L2_new)
}

```

Etiqueto los outliers superiores:

```{r}
data_features <- mutate(data_features,out_acousticness=if_else(data_features[,1] %in% outliers_sup[[1]],1,0))
data_features <- mutate(data_features,out_danceability=if_else(data_features[,2] %in% outliers_sup[[2]],1,0))
data_features <- mutate(data_features,out_duration_ms=if_else(data_features[,3] %in% outliers_sup[[3]],1,0))
data_features <- mutate(data_features,out_energy=if_else(data_features[,4] %in% outliers_sup[[4]],1,0))
data_features <- mutate(data_features,out_instrumentalness=if_else(data_features[,5] %in% outliers_sup[[1]],1,0))
data_features <- mutate(data_features,out_liveness=if_else(data_features[,6] %in% outliers_sup[[6]],1,0))
data_features <- mutate(data_features,out_loudness=if_else(data_features[,7] %in% outliers_sup[[7]],1,0))
data_features <- mutate(data_features,out_speechiness=if_else(data_features[,8] %in% outliers_sup[[8]],1,0))
```

Definiendo un umbral de 3,5 veces la mediana, calculamos los outliers inferiores:

```{r}
threshold = -3.5
var <- z_score_mod[,1]
L <- var[var<threshold]
umbrales_inf <- list(L)

for (i in c(2:8)){
  var <- z_score_mod[,i]
  L_new = list(var[var<threshold])
  umbrales_inf <- c(umbrales_inf,L_new)
}
var <- z_score_mod[,1]
var2 <- data_features[,1]
L2 <- var2[var<threshold]
outliers_inf <- list(L2)

for (i in c(2:8)){
  var <- z_score_mod[,i]
  var2 <- data_features[,i]
  L2_new = list(var2[var<threshold])
  outliers_inf <- c(outliers_inf,L2_new)
}
```

Etiqueto los outliers inferiores:

```{r}
data_features <- mutate(data_features,out_acousticness_in=if_else(data_features[,1] %in% outliers_inf[[1]],1,0))
data_features <- mutate(data_features,out_danceability_in=if_else(data_features[,2] %in% outliers_inf[[2]],1,0))
data_features <- mutate(data_features,out_duration_ms_in=if_else(data_features[,3] %in% outliers_inf[[3]],1,0))
data_features <- mutate(data_features,out_energy_in=if_else(data_features[,4] %in% outliers_inf[[4]],1,0))
data_features <- mutate(data_features,out_instrumentalness_in=if_else(data_features[,5] %in% outliers_inf[[1]],1,0))
data_features <- mutate(data_features,out_liveness_in=if_else(data_features[,6] %in% outliers_inf[[6]],1,0))
data_features <- mutate(data_features,out_loudness_in=if_else(data_features[,7] %in% outliers_inf[[7]],1,0))
data_features <- mutate(data_features,out_speechiness_in=if_else(data_features[,8] %in% outliers_inf[[8]],1,0))
```

Los outliers correspondientes en color azul:

```{r }
puntos1<-list()
puntos1[[1]] <- unique(outliers_sup[[3]])
puntos1[[2]] <- unique(outliers_sup[[5]])
puntos1[[3]] <- unique(outliers_sup[[6]])
puntos1[[4]] <- unique(outliers_sup[[8]])

puntos2<-list()
puntos2[[1]] <- unique(outliers_inf[[7]])

par(mfrow=c(2,4))

boxplot(data_features[,1],main=colnames(data_features)[1])

boxplot(data_features[,2],main=colnames(data_features)[2])

boxplot(data_features[,3],main=colnames(data_features)[3])
data1<-puntos1[[1]]
stripchart(data1, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'blue')

boxplot(data_features[,4],main=colnames(data_features)[4])

boxplot(data_features[,5],main=colnames(data_features)[5])
data1<-puntos1[[2]]
stripchart(data1, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'blue')

boxplot(data_features[,6],main=colnames(data_features)[6])
data1<-puntos1[[3]]
stripchart(data1, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'blue')

boxplot(data_features[,7],main=colnames(data_features)[7])
data1<-puntos2[[1]]
stripchart(data1, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'blue')

boxplot(data_features[,8],main=colnames(data_features)[8])
data1<-puntos1[[4]]
stripchart(data1, vertical = TRUE, method = "jitter", add = TRUE, pch = 20, col = 'blue')
```
Como se puede observar el metodo marca muchos puntos como outliers, esto es porque las distribuciones son muy asimetricas, por tanto debemos explorar otros metodos.

Calculamos el z-score para streams, streamsxartista, trackxartista, numberonexartista.
Nota: calcular mas arriba streamsxtrack para los track top.
